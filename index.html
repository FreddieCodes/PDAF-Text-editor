<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="./styles/style.css">
  <link rel="stylesheet" href="./styles/prism.css"/>
  <title>Text Editor</title>
</head>
<body>
  <div id="buttonarea">
    <button id ="load-button"> Load </button>
    <button id ="save-as-button"> Save As </button>
    <button id ="save-button"> Save</button>
    <button id ="syntax-button">Syntax</button>
    <button id ="word-count">Count</button>
    <button id ="save-position">Save Position</button>
    <button id ="restore-position">Restor Position</button>
  </div>

  <section class="container">
    <div class="left-half">
      <button id="tree-dir">Tree Directory</button>
      <li id="tree">
      </li>
    </div>
    <div class="right-half">
      <pre class="line-numbers"><code class="language-javascript" id="editor" contentEditable=true>function ()</code></pre>
    </div>
  </section>

<script type="text/javascript" src="./readFile.js"></script>
<script src="prism.js"></script>
<!-- Updating Syntax -->
<script>
const path = require("path");
// keypress event hashed out until cursor issues can be resolved.
document.addEventListener("keyup", updateSyntax);
var editor = document.getElementById("editor");
// position buttons
var savePositionBtn = document.getElementById("save-position")
var restorePositionBtn = document.getElementById("restore-position")

// syntaxBtn.addEventListener("click", updateSyntax);

restorePositionBtn.addEventListener("click", function(e){
   setCurrentCursorPosition(caretOffset);
});


function updateSyntax() {

  // getCurrentCursorPosition(editor)
  syntaxRecog()
  getCaretCharacterOffsetWithin()
  Prism.highlightElement(editor);
  setCurrentCursorPosition(caretOffset)
  // restoreRangePosition();
  // Prism.highlightAll();
}

const treeBtn = document.getElementById("tree-dir");
const li = document.getElementById("tree");

treeBtn.addEventListener("click", treeDir);

function treeDir() {
  const folder = "./";

  fs.readdir(folder, (err, files) => {
    files.forEach(file => {
      console.log(file);
      tree += `<li> ${file} </li>`;
    });
    li.innerHTML = tree;
  });
}

function syntaxRecog(){
    var fileLang = currentFileName.replace(/.*\./, "")
    
    var languages = { "css": "css",
                      "js": "javascript",
                      "rb": "ruby",
                      "html": "html",
                      "md": "markdown"
                    }
    
    // console.log(languages[fileLang.toString()])
    editor.className = `language-${languages[fileLang.toString()]}`
}
//  Cursor setting
// 

var caretOffset = 0

function getCaretCharacterOffsetWithin() {
    // var caretOffset = 0;
    var doc = editor.ownerDocument || editor.document;
    var win = doc.defaultView || doc.parentWindow;
    var sel;
    if (typeof win.getSelection != "undefined") {
        sel = win.getSelection();
        if (sel.rangeCount > 0) {
            var range = win.getSelection().getRangeAt(0);
            var preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(editor);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
        }
    } else if ( (sel = doc.selection) && sel.type != "Control") {
        var textRange = sel.createRange();
        var preCaretTextRange = doc.body.createTextRange();
        preCaretTextRange.moveToElementText(editor);
        preCaretTextRange.setEndPoint("EndToEnd", textRange);
        caretOffset = preCaretTextRange.text.length;
    }
    console.log("CARET log:", caretOffset)
    return caretOffset;
}


function createRange(node, chars, range) {
    if (!range) {
        range = document.createRange()
        range.selectNode(node);
        range.setStart(node, 0);
    }

    if (chars.count === 0) {
        range.setEnd(node, chars.count);
    } else if (node && chars.count >0) {
        if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent.length < chars.count) {
                chars.count -= node.textContent.length;
            } else {
                 range.setEnd(node, chars.count);
                 chars.count = 0;
            }
        } else {
            for (var lp = 0; lp < node.childNodes.length; lp++) {
                range = createRange(node.childNodes[lp], chars, range);

                if (chars.count === 0) {
                   break;
                }
            }
        }
   } 

   return range;
};

function setCurrentCursorPosition(chars) {
console.log(caretOffset)
    if (chars >= 0) {
        var selection = window.getSelection();

        range = createRange(document.getElementById("editor").parentNode, { count: chars });

        if (range) {
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
};

</script>
</body>
</html>
